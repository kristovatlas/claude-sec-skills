# Vulnerability Patterns Reference

Detailed patterns for identifying security vulnerabilities in web applications.

## XSS (Cross-Site Scripting)

### Reflected XSS
User input is immediately reflected in the response without sanitization.

**Dangerous Patterns:**
```javascript
// Direct DOM manipulation
element.innerHTML = userInput;
document.write(userInput);

// jQuery
$('#div').html(userInput);

// Template injection (unescaped)
<%= userInput %>  // EJS unescaped
{{{ userInput }}}  // Handlebars unescaped
```

**Safe Patterns:**
```javascript
// Using textContent (auto-escapes)
element.textContent = userInput;

// Template auto-escape
<%= escapeHtml(userInput) %>  // EJS escaped
{{ userInput }}  // Handlebars escaped (default)
{userInput}  // React/JSX (auto-escaped)
```

### Stored XSS
Malicious data stored in database, later rendered without escaping.

**Attack Vector:**
1. Attacker submits `<script>alert(1)</script>` via form
2. Application stores in database without sanitization
3. Application renders from database: `<div>${dbValue}</div>`
4. XSS executes in victim's browser

**Mitigation:**
- Sanitize on output (context-appropriate encoding)
- Use framework auto-escaping
- Implement Content Security Policy (CSP)

### DOM-based XSS
Client-side script uses untrusted data in dangerous sink.

**Dangerous Patterns:**
```javascript
// URL parameter to innerHTML
const param = new URLSearchParams(location.search).get('name');
document.getElementById('greeting').innerHTML = `Hello ${param}`;

// Window location to eval
eval(location.hash.substr(1));
```

## SQL Injection

### Classic SQLi
String concatenation in SQL queries.

**Vulnerable:**
```python
# Python
query = "SELECT * FROM users WHERE id = " + user_id
cursor.execute(query)

# PHP
$query = "SELECT * FROM users WHERE username = '" . $_POST['username'] . "'";
mysqli_query($conn, $query);

# Node.js
const query = `SELECT * FROM users WHERE email = '${req.body.email}'`;
connection.query(query);
```

**Safe:**
```python
# Python parameterized
query = "SELECT * FROM users WHERE id = %s"
cursor.execute(query, (user_id,))

# PHP prepared statement
$stmt = $pdo->prepare("SELECT * FROM users WHERE username = ?");
$stmt->execute([$_POST['username']]);

# Node.js parameterized
const query = "SELECT * FROM users WHERE email = ?";
connection.query(query, [req.body.email]);
```

### ORM SQLi
Raw queries in ORMs can still be vulnerable.

**Vulnerable:**
```javascript
// Sequelize raw query
User.sequelize.query(`SELECT * FROM users WHERE id = ${userId}`);

// TypeORM raw
userRepository.query(`DELETE FROM users WHERE role = '${role}'`);
```

**Safe:**
```javascript
// Sequelize with replacements
User.sequelize.query("SELECT * FROM users WHERE id = :id", {
  replacements: { id: userId }
});

// TypeORM query builder
userRepository.createQueryBuilder()
  .where("role = :role", { role: role })
  .getMany();
```

### Second-Order SQLi
Malicious data stored, then used unsafely in later query.

**Attack Flow:**
1. User registers with username: `admin' --`
2. Application stores in database (first query - safe)
3. Later, application uses username in query: `SELECT * FROM logs WHERE user = '` + username + `'`
4. Results in: `SELECT * FROM logs WHERE user = 'admin' --'` (SQLi!)

## Command Injection

### Shell Injection
User input passed to shell commands.

**Vulnerable:**
```python
# Python
os.system(f"ping -c 1 {user_ip}")  # Inject: 8.8.8.8; cat /etc/passwd

# PHP
shell_exec("convert " . $file . " output.pdf");

# Node.js
exec(`ffmpeg -i ${inputFile} output.mp4`);
```

**Safe:**
```python
# Python subprocess with list (no shell)
subprocess.run(["ping", "-c", "1", user_ip])

# Use libraries instead of shell
import requests
requests.get(f"http://{user_ip}")  # No shell involved
```

### Template Command Injection
Server-side template engines executing commands.

**Vulnerable:**
```python
# Jinja2 SSTI
template = Template(user_input)  # If user_input = "{{ ''.__class__.__mro__[1].__subclasses__() }}"

# ERB
ERB.new(user_input).result  # Ruby
```

## Path Traversal

### Directory Traversal
User controls file path without validation.

**Vulnerable:**
```javascript
// Node.js
const filename = req.query.file;
fs.readFile(`./uploads/${filename}`, callback);  
// Attack: ?file=../../../etc/passwd

// Python
file_path = request.args.get('file')
with open(f'/var/www/uploads/{file_path}') as f:  
// Attack: ?file=../../../../etc/passwd
```

**Safe:**
```javascript
// Validate against whitelist
const allowedFiles = ['report.pdf', 'invoice.pdf'];
if (!allowedFiles.includes(req.query.file)) {
  return res.status(400).send('Invalid file');
}

// Use path.normalize and check
const path = require('path');
const basePath = '/var/www/uploads';
const fullPath = path.normalize(path.join(basePath, req.query.file));
if (!fullPath.startsWith(basePath)) {
  return res.status(400).send('Invalid path');
}
```

### Zip Slip
Archive extraction without path validation.

**Vulnerable:**
```python
import zipfile
with zipfile.ZipFile(uploaded_file) as zf:
    zf.extractall('/var/www/uploads/')  
# Attack: zip contains "../../../var/www/html/shell.php"
```

**Safe:**
```python
import zipfile
import os

with zipfile.ZipFile(uploaded_file) as zf:
    for member in zf.namelist():
        # Normalize path and check it's within target
        member_path = os.path.normpath(os.path.join('/var/www/uploads/', member))
        if not member_path.startswith('/var/www/uploads/'):
            raise Exception(f'Invalid path: {member}')
        zf.extract(member, '/var/www/uploads/')
```

## SSRF (Server-Side Request Forgery)

### URL Parameter SSRF
Application fetches user-controlled URLs.

**Vulnerable:**
```javascript
// Fetch arbitrary URLs
const url = req.query.url;
const response = await fetch(url);  
// Attack: ?url=http://169.254.169.254/latest/meta-data/
```

**Safe:**
```javascript
// Whitelist allowed domains
const allowedDomains = ['api.trusted.com', 'cdn.trusted.com'];
const urlObj = new URL(req.query.url);
if (!allowedDomains.includes(urlObj.hostname)) {
  return res.status(400).send('Invalid URL');
}

// Disable redirects
const response = await fetch(url, { redirect: 'manual' });
```

### DNS Rebinding SSRF
Attacker controls DNS to bypass URL checks.

**Attack Flow:**
1. Application checks URL points to external domain (ok)
2. DNS resolves to external IP initially
3. Application fetches URL
4. Attacker changes DNS to point to internal IP (169.254.169.254)
5. Request goes to internal metadata service

**Mitigation:**
- Re-resolve DNS before each request
- Use IP whitelists, not domain whitelists
- Disable DNS caching for user-controlled URLs

## Insecure Deserialization

### Pickle/Marshal Deserialization
Deserializing untrusted data can execute code.

**Vulnerable:**
```python
# Python pickle
import pickle
data = pickle.loads(user_input)  # Can execute arbitrary code!

# Ruby
data = Marshal.load(user_input)
```

**Safe:**
```python
# Use JSON instead (data-only, no code)
import json
data = json.loads(user_input)

# Or use safe serialization
import jsonpickle
jsonpickle.set_decoder_options('json', strict=False)
```

### YAML Deserialization
YAML can execute code during deserialization.

**Vulnerable:**
```python
import yaml
config = yaml.load(user_input)  # Unsafe!
```

**Safe:**
```python
import yaml
config = yaml.safe_load(user_input)  # Safe loader only
```

## XXE (XML External Entity)

### Classic XXE
XML parser resolves external entities.

**Vulnerable XML:**
```xml
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>&xxe;</root>
```

**Mitigation:**
```python
# Python lxml - disable entities
from lxml import etree
parser = etree.XMLParser(resolve_entities=False)
tree = etree.parse(xml_file, parser)

# Python defusedxml
from defusedxml import ElementTree
tree = ElementTree.parse(xml_file)
```

## LDAP Injection

**Vulnerable:**
```python
search_filter = f"(uid={user_input})"
ldap.search_s(base_dn, ldap.SCOPE_SUBTREE, search_filter)
# Attack: user_input = "*)(uid=*" â†’ matches all users
```

**Safe:**
```python
# Escape LDAP special characters
import ldap
search_filter = f"(uid={ldap.filter.escape_filter_chars(user_input)})"
```

## Best Practice Checklist

For each vulnerability type, ensure:

**XSS:**
- [ ] Use framework auto-escaping
- [ ] Context-appropriate encoding
- [ ] Content Security Policy
- [ ] Avoid innerHTML, eval, unescaped templates

**SQL Injection:**
- [ ] Parameterized queries only
- [ ] No string concatenation in queries
- [ ] ORM query builders
- [ ] Least privilege database users

**Command Injection:**
- [ ] Avoid shell execution
- [ ] Use language APIs directly
- [ ] Input validation (whitelists)
- [ ] Disable dangerous functions

**Path Traversal:**
- [ ] Whitelist allowed paths/files
- [ ] Normalize and validate paths
- [ ] Restrict to base directory
- [ ] No user input in file paths

**SSRF:**
- [ ] URL domain whitelist
- [ ] Disable redirects
- [ ] Network segmentation
- [ ] No access to internal IPs

**Deserialization:**
- [ ] Avoid deserializing untrusted data
- [ ] Use safe serialization formats (JSON)
- [ ] Validate serialized data structure
- [ ] Use safe deserializers only
